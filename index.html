<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nostr Snake Game</title>
    <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" type="text/css" href="styles.css">
</head>
<body>
    <div class="header d-flex justify-content-between align-items-center p-3">
        <button class="btn btn-dark" id="login-button">Login with Nostr</button>
        <div class="action-buttons d-flex">
            <button class="btn btn-dark mr-2" id="restart-button">Restart</button>
            <button class="btn btn-dark" id="settings-button" style="display: none;">‚öôÔ∏è</button>
        </div>
        <div id="profile-pic">
            <span id="profile-emoji" aria-label="Profile Emoji">ü§ñ</span>
        </div>
    </div>
    <div class="game-container" id="game-container">
        <div class="score-container">
            <p id="score">Score: 0</p>
            <p id="highscore">High Score: 0</p>
        </div>
        <canvas id="game-canvas" width="400" height="400"></canvas>
        <div class="gameover-screen d-flex flex-column" id="gameover-screen">
            <h2>Game Over</h2>
            <button class="btn btn-dark mb-3" id="post-score-button">Post High Score</button>
            <div id="highscore-list">
                <h3>High Scores</h3>
                <ul class="list-unstyled"></ul>
            </div>
        </div>
    </div>
    <div id="feedback" role="status" class="text-center mt-3"></div>
    <div class="settings-popup" id="settings-popup">
        <button class="close-btn">‚úñÔ∏è</button>
        <h2>Select Your Snake</h2>
        <div class="emoji-list"></div>
    </div>
    <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.bundle.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const loginButton = document.getElementById('login-button');
            const profilePic = document.getElementById('profile-pic');
            const profileEmoji = document.getElementById('profile-emoji');
            const settingsButton = document.getElementById('settings-button');
            const settingsPopup = document.getElementById('settings-popup');
            const closeSettingsBtn = document.querySelector('.close-btn');
            const emojiListContainer = document.querySelector('.emoji-list');
            const gameContainer = document.getElementById('game-container');
            const scoreElement = document.getElementById('score');
            const highscoreElement = document.getElementById('highscore');
            const postScoreButton = document.getElementById('post-score-button');
            const gameoverScreen = document.getElementById('gameover-screen');
            const restartButton = document.getElementById('restart-button');
            const highscoreList = document.getElementById('highscore-list').querySelector('ul');
            const canvas = document.getElementById('game-canvas');
            const ctx = canvas.getContext('2d');
            const feedback = document.getElementById('feedback');
            const snakeHeadEmoji = 'üêç';
            const lightningEmoji = '‚ö°';
            const snakeColor = getComputedStyle(document.documentElement).getPropertyValue('--snake-color');
            let npub = null;
            let snake = [{ x: 10, y: 10 }];
            let lightning = { x: 5, y: 5 };
            let direction = { x: 0, y: 0 };
            let score = 0;
            let highscore = localStorage.getItem('highscore') || 0;
            let gameInterval;
            let isChangingDirection = false;
            let unlockedEmojis = JSON.parse(localStorage.getItem('unlockedEmojis')) || ['üêç'];
            let currentEmojiIndex = 0;

            highscoreElement.textContent = `High Score: ${highscore}`;
            postScoreButton.style.display = 'none';
            restartButton.style.display = 'none';

            function updateEmojiList() {
                emojiListContainer.innerHTML = '';
                unlockedEmojis.forEach((emoji, index) => {
                    const emojiItem = document.createElement('div');
                    emojiItem.textContent = emoji;
                    emojiItem.classList.add('emoji-item');
                    emojiItem.addEventListener('click', () => {
                        currentEmojiIndex = index;
                        profileEmoji.textContent = emoji;
                        settingsPopup.style.display = 'none';
                    });
                    emojiListContainer.appendChild(emojiItem);
                });
            }

            settingsButton.addEventListener('click', () => {
                updateEmojiList();
                settingsPopup.style.display = 'block';
            });

            closeSettingsBtn.addEventListener('click', () => {
                settingsPopup.style.display = 'none';
            });

            loginButton.addEventListener('click', async () => {
                if (window.nostr && window.nostr.getPublicKey) {
                    try {
                        npub = await window.nostr.getPublicKey();
                        const profile = await fetchProfile(npub);
                        if (profile && profile.picture) {
                            profilePic.innerHTML = `<img src="${profile.picture}" alt="Profile Picture">`;
                        }
                        displayPreviousHighScore();
                        loginButton.style.display = 'none';
                        restartButton.style.display = 'block';
                        settingsButton.style.display = 'block';
                        startGame();
                    } catch (error) {
                        console.error('Error logging in:', error);
                    }
                } else {
                    alert('NIP-07 extension not found.');
                }
            });

            async function fetchProfile(npub) {
                return new Promise((resolve, reject) => {
                    const ws = new WebSocket('wss://relay.damus.io');
                    ws.onopen = () => {
                        ws.send(JSON.stringify(["REQ", "1", { kinds: [0], authors: [npub] }]));
                    };
                    ws.onmessage = (event) => {
                        const data = JSON.parse(event.data);
                        if (data[0] === "EVENT" && data[2].content) {
                            const profile = JSON.parse(data[2].content);
                            ws.close();
                            resolve(profile);
                        }
                    };
                    ws.onerror = (error) => {
                        reject(error);
                    };
                });
            }

            function displayPreviousHighScore() {
                highscoreElement.textContent = `High Score: ${highscore}`;
            }

            function startGame() {
                gameContainer.style.display = 'block';
                gameoverScreen.style.display = 'none';
                postScoreButton.style.display = 'none';
                document.addEventListener('keydown', changeDirection);
                document.addEventListener('touchstart', handleTouchStart, { passive: false });
                document.addEventListener('touchmove', handleTouchMove, { passive: false });
                gameInterval = setInterval(updateGame, 100);
            }

            function restartGame() {
                clearInterval(gameInterval);
                snake = [{ x: 10, y: 10 }];
                direction = { x: 0, y: 0 };
                score = 0;
                scoreElement.textContent = `Score: ${score}`;
                startGame();
            }

            let xDown = null;
            let yDown = null;

            function handleTouchStart(evt) {
                evt.preventDefault();
                const firstTouch = evt.touches[0];
                xDown = firstTouch.clientX;
                yDown = firstTouch.clientY;
            }

            function handleTouchMove(evt) {
                evt.preventDefault();
                if (!xDown || !yDown) {
                    return;
                }

                const xUp = evt.touches[0].clientX;
                const yUp = evt.touches[0].clientY;

                const xDiff = xDown - xUp;
                const yDiff = yDown - yUp;

                if (Math.abs(xDiff) > Math.abs(yDiff)) {
                    if (xDiff > 0 && direction.x !== 1) {
                        direction = { x: -1, y: 0 }; // left swipe
                    } else if (xDiff < 0 && direction.x !== -1) {
                        direction = { x: 1, y: 0 }; // right swipe
                    }
                } else {
                    if (yDiff > 0 && direction.y !== 1) {
                        direction = { x: 0, y: -1 }; // up swipe
                    } else if (yDiff < 0 && direction.y !== -1) {
                        direction = { x: 0, y: 1 }; // down swipe
                    }
                }

                xDown = null;
                yDown = null;
            }

            function changeDirection(event) {
                if (isChangingDirection) return;
                isChangingDirection = true;

                const key = event.keyCode;
                if (key === 37 && direction.x !== 1) { // left arrow
                    direction = { x: -1, y: 0 };
                } else if (key === 38 && direction.y !== 1) { // up arrow
                    direction = { x: 0, y: -1 };
                } else if (key === 39 && direction.x !== -1) { // right arrow
                    direction = { x: 1, y: 0 };
                } else if (key === 40 && direction.y !== -1) { // down arrow
                    direction = { x: 0, y: 1 };
                }
            }

            function updateGame() {
                const head = { x: snake[0].x + direction.x, y: snake[0].y + direction.y };
                // Wrap-around feature
                if (head.x < 0) head.x = 19;
                if (head.x >= 20) head.x = 0;
                if (head.y < 0) head.y = 19;
                if (head.y >= 20) head.y = 0;
                snake.unshift(head);

                if (head.x === lightning.x && head.y === lightning.y) {
                    score++;
                    scoreElement.textContent = `Score: ${score}`;
                    lightning = { x: Math.floor(Math.random() * 20), y: Math.floor(Math.random() * 20) };
                } else {
                    snake.pop();
                }

                if (collision(head)) {
                    clearInterval(gameInterval);
                    if (score > highscore) {
                        highscore = score;
                        localStorage.setItem('highscore', highscore);
                        highscoreElement.textContent = `High Score: ${highscore}`;
                        unlockNewEmoji();
                    }
                    showGameOverScreen();
                }

                isChangingDirection = false;
                drawGame();
            }

            function collision(head) {
                return snake.slice(1).some(segment => segment.x === head.x && segment.y === head.y);
            }

            function drawGame() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                snake.forEach((segment, index) => {
                    ctx.fillText(unlockedEmojis[currentEmojiIndex], segment.x * 20, segment.y * 20 + 15);
                });

                ctx.fillText(lightningEmoji, lightning.x * 20, lightning.y * 20 + 15);
            }

            function showGameOverScreen() {
                gameoverScreen.style.display = 'flex';
                postScoreButton.style.display = 'block';
                fetchHighScores();
            }

            async function fetchHighScores() {
                highscoreList.innerHTML = '';
                const ws = new WebSocket('wss://relay.damus.io');
                ws.onopen = () => {
                    ws.send(JSON.stringify(["REQ", "2", { kinds: [69420] }]));
                };
                ws.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    if (data[0] === "EVENT" && data[2].content) {
                        const scoreTag = data[2].tags.find(tag => tag[0] === 's');
                        if (scoreTag) {
                            const score = scoreTag[1];
                            const profile = data[2].pubkey;
                            fetchProfile(profile).then(profileData => {
                                if (profileData.picture) {
                                    const li = document.createElement('li');
                                    li.innerHTML = `
                                        <img src="${profileData.picture}" alt="Profile Picture">
                                        <span>${profileData.name || profile}</span>: ${score}
                                    `;
                                    highscoreList.appendChild(li);
                                    sortHighScores();
                                }
                            });
                        }
                    }
                };
                ws.onerror = (error) => {
                    console.error('Error fetching high scores:', error);
                };
            }

            function sortHighScores() {
                const highScores = Array.from(highscoreList.children);
                highScores.sort((a, b) => {
                    const scoreA = parseInt(a.textContent.split(': ')[1], 10);
                    const scoreB = parseInt(b.textContent.split(': ')[1], 10);
                    return scoreB - scoreA;
                });
                highScores.forEach(li => highscoreList.appendChild(li));
            }

            postScoreButton.addEventListener('click', async () => {
                if (npub) {
                    try {
                        const event = {
                            kind: 69420,
                            content: `I scored ${highscore} in the snake game! #snakegame`,
                            tags: [['t', 'snakegame'], ['u', unlockedEmojis.join(',')], ['s', highscore.toString()]],
                            created_at: Math.floor(Date.now() / 1000)
                        };
                        const signedEvent = await window.nostr.signEvent(event);
                        postEvent(signedEvent);
                        feedback.textContent = 'High score posted to Nostr!';
                        setTimeout(() => { feedback.textContent = ''; }, 3000);
                        restartGame();
                    } catch (error) {
                        console.error('Error posting high score:', error);
                        feedback.textContent = 'Error posting high score to Nostr.';
                    }
                }
            });

            function postEvent(event) {
                const ws = new WebSocket('wss://relay.damus.io');
                ws.onopen = () => {
                    ws.send(JSON.stringify(["EVENT", event]));
                };
                ws.onmessage = (msg) => {
                    console.log('Event posted:', msg.data);
                    ws.close();
                };
                ws.onerror = (error) => {
                    console.error('Error posting event:', error);
                };
            }

            restartButton.addEventListener('click', restartGame);

            function unlockNewEmoji() {
                const newEmojis = ['üåü', 'üéâ', 'üî•', 'üíé', 'üöÄ']; // Add more emojis as needed
                const randomEmoji = newEmojis[Math.floor(Math.random() * newEmojis.length)];
                if (!unlockedEmojis.includes(randomEmoji)) {
                    unlockedEmojis.push(randomEmoji);
                    localStorage.setItem('unlockedEmojis', JSON.stringify(unlockedEmojis));
                    feedback.textContent = `New emoji unlocked: ${randomEmoji}!`;
                    setTimeout(() => { feedback.textContent = ''; }, 3000);
                    updateEmojiList();
                }
            }
        });
    </script>
</body>
</html>
